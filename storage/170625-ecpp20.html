title: [EC++ 20] Prefer pass-by-reference-to-<span style="background:#99ee99">&nbsp const &nbsp</span> to pass-by-value.
tag: 

<h3>Pass-by-reference-to-<span style="background:#99ee99">&nbsp const &nbsp</span></h3>의 좋은 점
<ul>
    <li>pass-by-value 로 인한 불필요한 ctor와 dtor의 호출을 막을 수 있다.</li>
    <li>Slicing problem을 막을 수 있다.</li>
    <quote style="background:#99ee99">
        param.로 어떤 객체를 받을 때, param.의 타입이 받으려는 객체의 base 클래스인 경우, param.로 그 객체를 받아 복사생성하는 과정에서 객체에서 derived 된 특성(data, function)이 잘려나가게 되는데, 이를 Slicing problem이라 한다.
    </quote>
    <li>단, built-in type의 경우 pass-by value가 더 효율적이다. 이는 iterator나 function object in STL에도 해당되는데, 이런 기능들이 pass by value로 건네주도록 설계되었기 때문이다.</li>
    <li>작은 크기의 객체라고 해서 반드시 pass-by-value가 효과적인 것은 아니다. </li>
    <p>
        몇몇 컴파일러의 경우 built in type과 User defined type를 다르게 취급하는 경우가 있다. 또한 나중에 type의 설계가 변경됨에 따라 user defined type의 크기가 더 커지는 등의 변화가 있을 수도 있다.
    </p>
    <li>일반적으로, pass-by-value로 넘겨도 적은 비용이 든다고 보장할 수 있는 type은 built-in type과 STL iterator 또는 fucntion object type이다.</li>

</ul>


<h3>Summary</h3>
<ul>
    <li>Prefer Pass-by-reference-to-<span style="background:#99ee99">&nbsp const &nbsp</span> over pass-by-value. It's typically more efficient and it avoids the slicing problem.</li>
    <li>The rule doesn't apply to built-in types and STL iterator and function object types. For them, pass-by-value is usually appropriate.</li>
</ul>

<h3>Reference</h3>
<ul>
    <li>Effective C++ by Scott Meyers</li>
</ul>

<span style="background:#99ee99">&nbsp&nbsp</span>